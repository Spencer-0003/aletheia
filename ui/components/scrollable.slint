export component Scrollable inherits Rectangle {
  in property <bool> enabled: true;
  in property <color> scrollbar_track_color: #1e1e2e;
  in property <color> scrollbar_thumb_color: #45475a;
  in property <color> scrollbar_thumb_hover_color: #7678ed;
  in property <length> scrollbar_width: 12px;
  in property <duration> scroll_animation_duration: 150ms;
  in-out property <length> viewport_height <=> flickable.viewport-height;
  in-out property <length> viewport_y <=> flickable.viewport-y;
  private property <bool> has_vertical_overflow: viewport_height > flickable.height;

  flickable := Flickable {
    width: parent.width;
    height: parent.height;
    interactive: root.enabled;

    animate viewport-y { duration: root.scroll_animation_duration; easing: ease-out; }

    @children
  }

  if root.has_vertical_overflow: Rectangle {
    x: parent.width - root.scrollbar_width - 4px;
    y: 4px;
    width: root.scrollbar_width;
    height: parent.height - 4px;

    Rectangle {
      width: 100%;
      height: 100%;
      background: root.scrollbar_track_color;
      border-radius: root.scrollbar_width / 2;
    }

    thumb := Rectangle {
      private property <float> scroll_ratio: -flickable.viewport-y / (flickable.viewport-height - flickable.height);
      private property <length> track_height: parent.height - 4px;
      private property <length> thumb_height: max(20px, (flickable.height / flickable.viewport-height) * track_height);
      private property <length> thumb_y: 2px + scroll_ratio * (track_height - thumb_height);
      x: 2px;
      y: self.thumb_y;
      width: parent.width - 4px;
      height: self.thumb_height;
      background: touch_area.has-hover ? root.scrollbar_thumb_hover_color : root.scrollbar_thumb_color;
      border-radius: (root.scrollbar_width - 4px) / 2;

      animate y { duration: root.scroll_animation_duration; easing: ease-out; }
      animate background { duration: 150ms; }
    }

    touch_area := TouchArea {
        private property <length> press_start_y;
        private property <length> press_start_viewport_y;
        private property <bool> is_dragging: false;
        width: parent.width;
        height: parent.height;

        moved => {
          if (self.pressed && self.is_dragging) {
            flickable.viewport-y = max(
              flickable.height - flickable.viewport-height,
              min(0px,
                self.press_start_viewport_y -
                (self.mouse-y - self.press_start_y) *
                (flickable.viewport-height - flickable.height) /
                (parent.height - thumb.height - 4px)
              )
            );
          }
        }

        pointer-event(event) => {
          if (event.kind == PointerEventKind.down) {
            self.press_start_y = self.mouse-y;
            self.press_start_viewport_y = flickable.viewport-y;
            self.is_dragging = true;
          } else if (event.kind == PointerEventKind.up) {
            self.is_dragging = false;
          }
        }
    }
  }
}